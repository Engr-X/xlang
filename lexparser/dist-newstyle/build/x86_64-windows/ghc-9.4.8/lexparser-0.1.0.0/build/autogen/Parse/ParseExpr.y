{
module Parse.ParseExpr where
import Unsafe.Coerce (unsafeCoerce)
import Data.List (intercalate)
import Data.Maybe (fromMaybe)
import Lex.Token (Token, tokenPos)
import Lex.Tokenizer (tokenizeWithNL)
import Parse.SyntaxTree
import Parse.ParserBasic
import Util.Exception (ErrorKind, makeError, expectedExpression, assignErrorMsg)
import Util.Type (Path)
import qualified Lex.Token as Lex
import qualified Util.Exception as UE
}
%name parseExpr Start
%tokentype { Token }
%error { parseExprError }
%token
    EOF { t@(Lex.EOF _) }
    KW_TRUE { t@(Lex.Ident "true" _) }
    KW_FALSE { t@(Lex.Ident "false" _) }
    KW_AS { t@(Lex.Ident "as" _) }
    identity { t@(Lex.Ident _ _) }
    number { t@(Lex.NumberConst _ _) }
    character { t@(Lex.CharConst _ _) }
    string { t@(Lex.StrConst _ _) }
    '=' { t@(Lex.Symbol Lex.Assign _) }
    '>' { t@(Lex.Symbol Lex.GreaterThan _) }
    '<' { t@(Lex.Symbol Lex.LessThan _) }
    '==' { t@(Lex.Symbol Lex.Equal _) }
    '!=' { t@(Lex.Symbol Lex.NotEqual _) }
    '+' { t@(Lex.Symbol Lex.Plus _) }
    '-' { t@(Lex.Symbol Lex.Minus _) }
    '*' { t@(Lex.Symbol Lex.Multiply _) }
    '/' { t@(Lex.Symbol Lex.Divide _) }
    '(' { t@(Lex.Symbol Lex.LParen _) }
    ')' { t@(Lex.Symbol Lex.RParen _) }
    '.' { t@(Lex.Symbol Lex.Dot _) }
%right '='
%left '!=' '=='
%left '>' '<'
%left '+' '-'
%left '*' '/'
%right UPLUS UMINUS
%%
Start
    : Expr EOF { $1 }
    ;
QName
    : identity { ([identText $1], [$1]) }
    | QName '.' identity { let (xs, ts) = $1 in (xs ++ [identText $3], ts ++ [$3]) }
    ;
LValue : QName { qnameToExpr $1 };
Type : QName { let (xs, _) = $1 in toClass (intercalate "." xs) };
Atom
    : KW_TRUE { BoolConst True $1}
    | KW_FALSE { BoolConst False $1}
    -- unary operators
    | '+' Atom %prec UPLUS { Unary UnaryPlus $2 $1}
    | '+' error %prec UPLUS { Error $1 (expectedExpression 1 "+")}
    | '-' Atom %prec UMINUS { Unary UnaryMinus $2 $1}
    | '-' error %prec UMINUS { Error $1 (expectedExpression 1 "-") }
    -- parenthesized expression
    | '(' Expr ')' { $2 }
    -- identifiers
    | QName { qnameToExpr $1 }
    -- literals
    | number { fromMaybe (Error $1 "classifyNumber failed") (classifyNumber (numText $1) $1) }
    | character { CharConst (charVal $1) $1 }
    | string { StringConst (strVal $1) $1 }
    ;
Postfix
    : Atom { $1 }
    -- cast
    | Postfix KW_AS Type { Cast $3 $1 $2 }
    | Postfix KW_AS error { Error $2 (expectedExpression 0 "as") }
    ;
Expr
    : LValue '=' Expr { if isVariable $1 then Binary Assign $1 $3 $2 else Error $2 assignErrorMsg }
    | LValue '=' error { Error $2 (expectedExpression 1 "=") }
    --
    | Expr '==' Expr { Binary Equal $1 $3 $2}
    | Expr '==' error { Error $2 (expectedExpression 1 "==") }
    | Expr '!=' Expr { Binary NotEqual $1 $3 $2}
    | Expr '!=' error { Error $2 (expectedExpression 1 "!=") }
    | Expr '>' Expr { Binary GreaterThan $1 $3 $2}
    | Expr '>' error { Error $2 (expectedExpression 1 ">") }
    | Expr '<' Expr { Binary LessThan $1 $3 $2}
    | Expr '<' error { Error $2 (expectedExpression 1 "<") }
    --
    | Expr '+' Expr { Binary Add $1 $3 $2}
    | Expr '+' error { Error $2 (expectedExpression 1 "+") }
    | Expr '-' Expr { Binary Sub $1 $3 $2}
    | Expr '-' error { Error $2 (expectedExpression 1 "-") }
    | Expr '*' Expr { Binary Mul $1 $3 $2}
    | Expr '*' error { Error $2 (expectedExpression 1 "*") }
    | Expr '/' Expr { Binary Div $1 $3 $2}
    | Expr '/' error { Error $2 (expectedExpression 1 "/") }
    | Postfix { $1 }
    ;
{
-- | Happy-required error continuation for expression parsing.
--
-- Happy enforces a polymorphic error handler of type:
-- [Token] -> a
--
-- However, our parser produces a concrete 'Expression' as the error result.
-- To bridge this mismatch, we deliberately use 'unsafeCoerce' here to coerce
-- an 'Expression' into the expected polymorphic return type.
--
-- This function should ONLY be used as the 'parseError' hook generated by Happy.
-- Any misuse outside the parser error path is undefined behavior.
parseExprError :: [Token] -> a
parseExprError toks = unsafeCoerce (mkHappyErrorExpr toks)
-- | High-level entry point for lexing + parsing a single expression.
--
-- This function performs the following pipeline:
--
-- 1. Tokenize the input source string with newline inference.
-- 2. If lexical errors exist, return them immediately.
-- 3. Parse the token stream into an 'Expression'.
-- 4. Traverse the resulting AST to collect embedded parse errors.
-- 5. Convert all expression-level errors into unified 'ErrorKind's.
--
-- On success, returns:
-- Right Expression
--
-- On failure, returns:
-- Left [ErrorKind]
--
-- This design intentionally separates:
-- * lexing errors (returned directly)
-- * parsing errors (embedded in AST, then extracted)
lexparseExpr :: Path -> String -> Either [ErrorKind] Expression
lexparseExpr p str = let (errs, tokens) = tokenizeWithNL p str in case errs of
    [] -> let expr = parseExpr tokens in case getErrorProgram ([], [Expr expr]) of
        [] -> Right expr
        errs -> Left $ map (toException p) errs
    _ -> Left errs
-- | used for debug version
replLexparseExpr :: String -> Either [ErrorKind] Expression
replLexparseExpr = lexparseExpr "stdin"
}
