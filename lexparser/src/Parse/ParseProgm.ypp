{
module Parse.ParseProgm where


import Unsafe.Coerce (unsafeCoerce)
import Data.List (intercalate)
import Data.Maybe (fromMaybe)
import Lex.Token (Token)
import Parse.SyntaxTree
import Parse.ParserBasic (mkHappyErrorExpr, classifyNumber)
import Util.Exception (expectedExpression)

import qualified Lex.Token as Lex
}

%name parseProgm ProgramEOF

%tokentype { Token }
%error { parseProgmError }

%token
    -- keywords (Ident)
    KW_TRUE             { Lex.Ident "true" _ }
    KW_FALSE            { Lex.Ident "false" _ }
    KW_AS               { Lex.Ident "as" _ }

    -- literals / identifiers
    identity            { Lex.Ident $$ _ }
    number              { Lex.NumberConst $$ _ }
    character           { Lex.CharConst $$ _ }
    string              { Lex.StrConst $$ _ }

    -- newline / eof
    NL                  { Lex.NewLine _ }
    EOF                 { Lex.EOF _ }

    -- symbols (Expr)
    '.'                 { Lex.Symbol Lex.Dot _ }
    '+'                 { Lex.Symbol Lex.Plus _ }
    '-'                 { Lex.Symbol Lex.Minus _ }
    '*'                 { Lex.Symbol Lex.Multiply _ }
    '/'                 { Lex.Symbol Lex.Divide _ }
    '('                 { Lex.Symbol Lex.LParen _ }
    ')'                 { Lex.Symbol Lex.RParen _ }

    -- symbols (Stmt/Block)
    '{'                 { Lex.Symbol Lex.LBrace _ }
    '}'                 { Lex.Symbol Lex.RBrace _ }
    ';'                 { Lex.Symbol Lex.Semicolon _ }

%left '+' '-'
%left '*' '/'
%right UPLUS UMINUS

%%

-- ============================================================
-- Entry
-- ============================================================

ProgramEOF :: { Program }
  : OptTerms StmtSeq OptTerms EOF { ([], $2) }

-- ============================================================
-- Separators / terminators
-- ============================================================

Term :: { () }
    : ';' { () }
    | NL  { () }

OptTerms :: { () }
    : {- empty -}   { () }
    | OptTerms Term { () }

-- ============================================================
-- Top-level statements (minimal)
-- ============================================================

StmtSeq :: { [Statement] }
    : {- empty -}            { [] }
    | StmtSeq OptTerms Stmt  { $1 ++ [$3] }
    ;

Stmt :: { Statement }
    : ExprStmt { Expr $1 }
    | Block    { BlockStmt $1 }
    ;

ExprStmt :: { Expression }
    : Expr Term { $1 }
    ;

Block :: { Block }
    : '{' BlockBody '}' { Multiple $2 }
    ;

BlockBody :: { [Statement] }
    : {- empty -}        { [] }
    | BlockBody Term     { $1 }
    | BlockBody Stmt     { $1 ++ [$2] }
    ;

-- ============================================================
-- Shared expression grammar
-- ============================================================

#include "Parse/GrammarExpr.inc"

{
-- English comment: Happy 2.0 expects a polymorphic error handler.
-- We return a sentinel program containing one error expression statement.
parseProgmError :: [Token] -> a
parseProgmError toks =
    let e  = mkHappyErrorExpr toks
        pr = ([], [Expr e]) :: Program in unsafeCoerce pr
}
