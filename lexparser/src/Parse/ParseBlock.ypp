{
module Parse.ParseBlock where

import Unsafe.Coerce (unsafeCoerce)
import Data.List (intercalate)
import Data.Maybe (fromMaybe)
import Lex.Token (Token, tokenPos)
import Lex.Tokenizer (tokenizeWithNL)
import Parse.SyntaxTree
import Parse.ParserBasic
import Util.Exception (ErrorKind, makeError, expectedExpression, assignErrorMsg)
import Util.Type (Path)

import qualified Lex.Token as Lex
import qualified Util.Exception as UE
}

%name parseBlock BlockEOF
%tokentype { Token }
%error { parseBlockError }

%token
    -- keywords
    EOF                 { t@(Lex.EOF _) }
    NL                  { t@(Lex.NewLine _) }
    KW_TRUE             { t@(Lex.Ident "true" _) }
    KW_FALSE            { t@(Lex.Ident "false" _) }
    KW_AS               { t@(Lex.Ident "as" _) }

    -- literals / identifiers
    identity            { t@(Lex.Ident _ _) }
    number              { t@(Lex.NumberConst _ _) }
    character           { t@(Lex.CharConst _ _) }
    string              { t@(Lex.StrConst _ _) }

    -- expression symbols
    '='                 { t@(Lex.Symbol Lex.Assign _) }
    '+'                 { t@(Lex.Symbol Lex.Plus _) }
    '-'                 { t@(Lex.Symbol Lex.Minus _) }
    '*'                 { t@(Lex.Symbol Lex.Multiply _) }
    '/'                 { t@(Lex.Symbol Lex.Divide _) }
    '('                 { t@(Lex.Symbol Lex.LParen _) }
    ')'                 { t@(Lex.Symbol Lex.RParen _) }

    -- statement / block symbols
    '.'                 { t@(Lex.Symbol Lex.Dot _) }
    '{'                 { t@(Lex.Symbol Lex.LBrace _) }
    '}'                 { t@(Lex.Symbol Lex.RBrace _) }
    ';'                 { t@(Lex.Symbol Lex.Semicolon _) }

%right '='
%left '+' '-'
%left '*' '/'
%right UPLUS UMINUS

%%

#include "Parse/GrammarStmtBlock.inc"
#include "Parse/GrammarExpr.inc"

{
-- Happy 2.0 expects a polymorphic error handler.
-- We return a sentinel block containing a single error expression statement.
parseBlockError :: [Token] -> a
parseBlockError toks =
    let e = mkHappyErrorExpr toks
        bl = Multiple [Expr e] in unsafeCoerce bl


-- parse for block into ast tree
lexparseBlock :: Path -> String -> Either [ErrorKind] Block
lexparseBlock p str =
    let (errs, tokens) = tokenizeWithNL p str
    in case errs of
        [] ->
            let blk = parseBlock tokens
            in case getErrorProgram ([], [BlockStmt blk]) of
                [] -> Right blk
                es -> Left $ map (toException p) es
        _  -> Left errs


-- |  used for debug version
replLexparseBlock :: String -> Either [ErrorKind] Block
replLexparseBlock = lexparseBlock "stdin"
}
