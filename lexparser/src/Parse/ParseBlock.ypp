{
module Parse.ParseBlock where

import Unsafe.Coerce (unsafeCoerce)
import Data.List (intercalate)
import Data.Maybe (fromMaybe)
import Lex.Token (Token)
import Parse.SyntaxTree
import Parse.ParserBasic (mkHappyErrorExpr, classifyNumber)
import Util.Exception (expectedExpression)

import Unsafe.Coerce (unsafeCoerce)

import qualified Lex.Token as Lex
}

%name parseBlock BlockEOF

%tokentype { Token }
%error { parseBlockError }

%token
    -- keywords (Ident)
    KW_TRUE             { Lex.Ident "true" _ }
    KW_FALSE            { Lex.Ident "false" _ }
    KW_AS               { Lex.Ident "as" _ }

    -- literals / identifiers
    identity            { Lex.Ident $$ _ }
    number              { Lex.NumberConst $$ _ }
    character           { Lex.CharConst $$ _ }
    string              { Lex.StrConst $$ _ }

    -- newline / eof
    NL                  { Lex.NewLine _ }
    EOF                 { Lex.EOF _ }

    -- symbols (Expr)
    '.'                 { Lex.Symbol Lex.Dot _ }
    '+'                 { Lex.Symbol Lex.Plus _ }
    '-'                 { Lex.Symbol Lex.Minus _ }
    '*'                 { Lex.Symbol Lex.Multiply _ }
    '/'                 { Lex.Symbol Lex.Divide _ }
    '('                 { Lex.Symbol Lex.LParen _ }
    ')'                 { Lex.Symbol Lex.RParen _ }

    -- symbols (Stmt/Block)
    '{'                 { Lex.Symbol Lex.LBrace _ }
    '}'                 { Lex.Symbol Lex.RBrace _ }
    ';'                 { Lex.Symbol Lex.Semicolon _ }

%left '+' '-'
%left '*' '/'
%right UPLUS UMINUS

%%

-- ============================================================
-- Entry
-- ============================================================

BlockEOF :: { Block }
    : OptTerms Block OptTerms EOF { $2 }

-- ============================================================
-- Separators / terminators
-- ============================================================

Term :: { () }
    : ';' { () }
    | NL  { () }

OptTerms :: { () }
    : {- empty -}   { () }
    | OptTerms Term { () }

-- ============================================================
-- Minimal statements inside a block
-- ============================================================

Stmt :: { Statement }
    : ExprStmt { Expr $1 }
    | Block    { BlockStmt $1 }
    ;

ExprStmt :: { Expression }
    : Expr Term { $1 }
    ;

-- ============================================================
-- Block
-- ============================================================

Block :: { Block }
    : '{' BlockBody '}' { Multiple $2 }
    ;

BlockBody :: { [Statement] }
    : {- empty -}        { [] }
    | BlockBody Term     { $1 }
    | BlockBody Stmt     { $1 ++ [$2] }
    ;

-- ============================================================
-- Shared expression grammar
-- ============================================================

#include "Parse/GrammarExpr.inc"

{
-- Happy 2.0 expects a polymorphic error handler.
-- We return a sentinel block containing a single error expression statement.
parseBlockError :: [Token] -> a
parseBlockError toks =
    let e = mkHappyErrorExpr toks
        bl = Multiple [Expr e] in unsafeCoerce bl
}
