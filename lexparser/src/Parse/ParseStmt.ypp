{
module Parse.ParseStmt where

import Unsafe.Coerce (unsafeCoerce)
import Data.List (intercalate)
import Data.Maybe (fromMaybe)
import Lex.Token (Token)
import Parse.SyntaxTree
import Parse.ParserBasic
import Util.Exception (expectedExpression, assignErrorMsg)

import qualified Lex.Token as Lex
}

%name parseStmt StmtEOF
%tokentype { Token }
%error { parseStmtError }

%token
    EOF                 { Lex.EOF _ }
    NL                  { Lex.NewLine _ }
    KW_TRUE             { Lex.Ident "true" _ }
    KW_FALSE            { Lex.Ident "false" _ }
    KW_AS               { Lex.Ident "as" _ }

    -- literals / identifiers
    identity            { Lex.Ident $$ _ }
    number              { Lex.NumberConst $$ _ }
    character           { Lex.CharConst $$ _ }
    string              { Lex.StrConst $$ _ }


    -- expression symbols
    '='                 { Lex.Symbol Lex.Assign _ }
    '+'                 { Lex.Symbol Lex.Plus _ }
    '-'                 { Lex.Symbol Lex.Minus _ }
    '*'                 { Lex.Symbol Lex.Multiply _ }
    '/'                 { Lex.Symbol Lex.Divide _ }
    '('                 { Lex.Symbol Lex.LParen _ }
    ')'                 { Lex.Symbol Lex.RParen _ }

    -- statement / block symbols
    '{'                 { Lex.Symbol Lex.LBrace _ }
    '}'                 { Lex.Symbol Lex.RBrace _ }
    '.'                 { Lex.Symbol Lex.Dot _ }
    ';'                 { Lex.Symbol Lex.Semicolon _ }

%right '='
%left '+' '-'
%left '*' '/'
%right UPLUS UMINUS

%%

StmtEOF :: { Statement } : OptTerms Stmt OptTerms EOF { $2 }

#include "Parse/GrammarStmtBlock.inc"
#include "Parse/GrammarExpr.inc"

{
-- Happy 2.0 expects a polymorphic error handler.
-- We return a sentinel statement containing one error expression.
parseStmtError :: [Token] -> a
parseStmtError toks =
    let e = mkHappyErrorExpr toks
        st = Expr e :: Statement
    in unsafeCoerce st
}